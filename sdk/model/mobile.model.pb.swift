// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: pb/apis/mobile.model.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Pb_MobileEventType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case mobileEventUnspecified // = 0
  case mobileEventGooglepayIsReadyToPayRequest // = 1
  case mobileEventGooglepayIsReadyToPayResponse // = 2
  case mobileEventGooglepayPaymentDataRequest // = 3
  case mobileEventGooglepayPaymentDataResponse // = 4
  case mobileEventGooglepayPaymentDataError // = 5
  case mobileEventApplepayIsReadyToPayRequest // = 6
  case mobileEventApplepayIsReadyToPayResponse // = 7
  case mobileEventApplepayPaymentDataRequest // = 8
  case mobileEventApplepayPaymentDataResponse // = 9
  case mobileEventApplepayPaymentDataError // = 10
  case mobileEventOpenURLRequest // = 11
  case mobileEventBack // = 12
  case mobileEventShareURLRequest // = 13
  case mobileEventGetParamsRequest // = 14
  case mobileEventGetParamsResponse // = 15
  case mobileEventSetParamsRequest // = 16
  case mobileEventCreateKeysRequest // = 17
  case mobileEventCreateKeysResponse // = 18
  case mobileEventParamsUpdated // = 19
  case mobileEventAnalyticsEvent // = 20
  case mobileEventClipboardWrite // = 21
  case mobileEventReview // = 22
  case UNRECOGNIZED(Int)

  public init() {
    self = .mobileEventUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .mobileEventUnspecified
    case 1: self = .mobileEventGooglepayIsReadyToPayRequest
    case 2: self = .mobileEventGooglepayIsReadyToPayResponse
    case 3: self = .mobileEventGooglepayPaymentDataRequest
    case 4: self = .mobileEventGooglepayPaymentDataResponse
    case 5: self = .mobileEventGooglepayPaymentDataError
    case 6: self = .mobileEventApplepayIsReadyToPayRequest
    case 7: self = .mobileEventApplepayIsReadyToPayResponse
    case 8: self = .mobileEventApplepayPaymentDataRequest
    case 9: self = .mobileEventApplepayPaymentDataResponse
    case 10: self = .mobileEventApplepayPaymentDataError
    case 11: self = .mobileEventOpenURLRequest
    case 12: self = .mobileEventBack
    case 13: self = .mobileEventShareURLRequest
    case 14: self = .mobileEventGetParamsRequest
    case 15: self = .mobileEventGetParamsResponse
    case 16: self = .mobileEventSetParamsRequest
    case 17: self = .mobileEventCreateKeysRequest
    case 18: self = .mobileEventCreateKeysResponse
    case 19: self = .mobileEventParamsUpdated
    case 20: self = .mobileEventAnalyticsEvent
    case 21: self = .mobileEventClipboardWrite
    case 22: self = .mobileEventReview
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .mobileEventUnspecified: return 0
    case .mobileEventGooglepayIsReadyToPayRequest: return 1
    case .mobileEventGooglepayIsReadyToPayResponse: return 2
    case .mobileEventGooglepayPaymentDataRequest: return 3
    case .mobileEventGooglepayPaymentDataResponse: return 4
    case .mobileEventGooglepayPaymentDataError: return 5
    case .mobileEventApplepayIsReadyToPayRequest: return 6
    case .mobileEventApplepayIsReadyToPayResponse: return 7
    case .mobileEventApplepayPaymentDataRequest: return 8
    case .mobileEventApplepayPaymentDataResponse: return 9
    case .mobileEventApplepayPaymentDataError: return 10
    case .mobileEventOpenURLRequest: return 11
    case .mobileEventBack: return 12
    case .mobileEventShareURLRequest: return 13
    case .mobileEventGetParamsRequest: return 14
    case .mobileEventGetParamsResponse: return 15
    case .mobileEventSetParamsRequest: return 16
    case .mobileEventCreateKeysRequest: return 17
    case .mobileEventCreateKeysResponse: return 18
    case .mobileEventParamsUpdated: return 19
    case .mobileEventAnalyticsEvent: return 20
    case .mobileEventClipboardWrite: return 21
    case .mobileEventReview: return 22
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Pb_MobileEventType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Pb_MobileEventType] = [
    .mobileEventUnspecified,
    .mobileEventGooglepayIsReadyToPayRequest,
    .mobileEventGooglepayIsReadyToPayResponse,
    .mobileEventGooglepayPaymentDataRequest,
    .mobileEventGooglepayPaymentDataResponse,
    .mobileEventGooglepayPaymentDataError,
    .mobileEventApplepayIsReadyToPayRequest,
    .mobileEventApplepayIsReadyToPayResponse,
    .mobileEventApplepayPaymentDataRequest,
    .mobileEventApplepayPaymentDataResponse,
    .mobileEventApplepayPaymentDataError,
    .mobileEventOpenURLRequest,
    .mobileEventBack,
    .mobileEventShareURLRequest,
    .mobileEventGetParamsRequest,
    .mobileEventGetParamsResponse,
    .mobileEventSetParamsRequest,
    .mobileEventCreateKeysRequest,
    .mobileEventCreateKeysResponse,
    .mobileEventParamsUpdated,
    .mobileEventAnalyticsEvent,
    .mobileEventClipboardWrite,
    .mobileEventReview,
  ]
}

#endif  // swift(>=4.2)

public enum Pb_MobileAnalyticsEventType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unspecified // = 0
  case androidAppInstallReferrer // = 1
  case androidIauInstall // = 2
  case androidIauCancel // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .androidAppInstallReferrer
    case 2: self = .androidIauInstall
    case 3: self = .androidIauCancel
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .androidAppInstallReferrer: return 1
    case .androidIauInstall: return 2
    case .androidIauCancel: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Pb_MobileAnalyticsEventType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Pb_MobileAnalyticsEventType] = [
    .unspecified,
    .androidAppInstallReferrer,
    .androidIauInstall,
    .androidIauCancel,
  ]
}

#endif  // swift(>=4.2)

public struct Pb_MobileEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Pb_MobileEventType = .mobileEventUnspecified

  public var payload: Pb_MobileEvent.OneOf_Payload? = nil

  public var error: Pb_MobileError {
    get {
      if case .error(let v)? = payload {return v}
      return Pb_MobileError()
    }
    set {payload = .error(newValue)}
  }

  public var isReadyToPayRequest: Pb_IsReadyToPayRequest {
    get {
      if case .isReadyToPayRequest(let v)? = payload {return v}
      return Pb_IsReadyToPayRequest()
    }
    set {payload = .isReadyToPayRequest(newValue)}
  }

  public var paymentDataRequest: Pb_PaymentDataRequest {
    get {
      if case .paymentDataRequest(let v)? = payload {return v}
      return Pb_PaymentDataRequest()
    }
    set {payload = .paymentDataRequest(newValue)}
  }

  public var isReadyToPay: Bool {
    get {
      if case .isReadyToPay(let v)? = payload {return v}
      return false
    }
    set {payload = .isReadyToPay(newValue)}
  }

  public var paymentData: Pb_PaymentData {
    get {
      if case .paymentData(let v)? = payload {return v}
      return Pb_PaymentData()
    }
    set {payload = .paymentData(newValue)}
  }

  public var applepayPaymentDataRequest: Pb_ApplePayPaymentDataRequest {
    get {
      if case .applepayPaymentDataRequest(let v)? = payload {return v}
      return Pb_ApplePayPaymentDataRequest()
    }
    set {payload = .applepayPaymentDataRequest(newValue)}
  }

  public var applepayPaymentData: Pb_ApplePayPaymentData {
    get {
      if case .applepayPaymentData(let v)? = payload {return v}
      return Pb_ApplePayPaymentData()
    }
    set {payload = .applepayPaymentData(newValue)}
  }

  public var openURLRequest: String {
    get {
      if case .openURLRequest(let v)? = payload {return v}
      return String()
    }
    set {payload = .openURLRequest(newValue)}
  }

  public var shareURLRequest: String {
    get {
      if case .shareURLRequest(let v)? = payload {return v}
      return String()
    }
    set {payload = .shareURLRequest(newValue)}
  }

  public var applicationParams: Pb_MobileApplicationParams {
    get {
      if case .applicationParams(let v)? = payload {return v}
      return Pb_MobileApplicationParams()
    }
    set {payload = .applicationParams(newValue)}
  }

  public var createKeysRequest: Pb_CreateKeysRequest {
    get {
      if case .createKeysRequest(let v)? = payload {return v}
      return Pb_CreateKeysRequest()
    }
    set {payload = .createKeysRequest(newValue)}
  }

  public var createKeysResponse: Pb_CreateKeysResponse {
    get {
      if case .createKeysResponse(let v)? = payload {return v}
      return Pb_CreateKeysResponse()
    }
    set {payload = .createKeysResponse(newValue)}
  }

  public var applicationParamsUpdate: Pb_MobileApplicationParamsUpdate {
    get {
      if case .applicationParamsUpdate(let v)? = payload {return v}
      return Pb_MobileApplicationParamsUpdate()
    }
    set {payload = .applicationParamsUpdate(newValue)}
  }

  public var analyticsEvent: Pb_MobileAnalyticsEvent {
    get {
      if case .analyticsEvent(let v)? = payload {return v}
      return Pb_MobileAnalyticsEvent()
    }
    set {payload = .analyticsEvent(newValue)}
  }

  public var clipboardWrite: String {
    get {
      if case .clipboardWrite(let v)? = payload {return v}
      return String()
    }
    set {payload = .clipboardWrite(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case error(Pb_MobileError)
    case isReadyToPayRequest(Pb_IsReadyToPayRequest)
    case paymentDataRequest(Pb_PaymentDataRequest)
    case isReadyToPay(Bool)
    case paymentData(Pb_PaymentData)
    case applepayPaymentDataRequest(Pb_ApplePayPaymentDataRequest)
    case applepayPaymentData(Pb_ApplePayPaymentData)
    case openURLRequest(String)
    case shareURLRequest(String)
    case applicationParams(Pb_MobileApplicationParams)
    case createKeysRequest(Pb_CreateKeysRequest)
    case createKeysResponse(Pb_CreateKeysResponse)
    case applicationParamsUpdate(Pb_MobileApplicationParamsUpdate)
    case analyticsEvent(Pb_MobileAnalyticsEvent)
    case clipboardWrite(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Pb_MobileEvent.OneOf_Payload, rhs: Pb_MobileEvent.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.isReadyToPayRequest, .isReadyToPayRequest): return {
        guard case .isReadyToPayRequest(let l) = lhs, case .isReadyToPayRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.paymentDataRequest, .paymentDataRequest): return {
        guard case .paymentDataRequest(let l) = lhs, case .paymentDataRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.isReadyToPay, .isReadyToPay): return {
        guard case .isReadyToPay(let l) = lhs, case .isReadyToPay(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.paymentData, .paymentData): return {
        guard case .paymentData(let l) = lhs, case .paymentData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.applepayPaymentDataRequest, .applepayPaymentDataRequest): return {
        guard case .applepayPaymentDataRequest(let l) = lhs, case .applepayPaymentDataRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.applepayPaymentData, .applepayPaymentData): return {
        guard case .applepayPaymentData(let l) = lhs, case .applepayPaymentData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.openURLRequest, .openURLRequest): return {
        guard case .openURLRequest(let l) = lhs, case .openURLRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.shareURLRequest, .shareURLRequest): return {
        guard case .shareURLRequest(let l) = lhs, case .shareURLRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.applicationParams, .applicationParams): return {
        guard case .applicationParams(let l) = lhs, case .applicationParams(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.createKeysRequest, .createKeysRequest): return {
        guard case .createKeysRequest(let l) = lhs, case .createKeysRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.createKeysResponse, .createKeysResponse): return {
        guard case .createKeysResponse(let l) = lhs, case .createKeysResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.applicationParamsUpdate, .applicationParamsUpdate): return {
        guard case .applicationParamsUpdate(let l) = lhs, case .applicationParamsUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.analyticsEvent, .analyticsEvent): return {
        guard case .analyticsEvent(let l) = lhs, case .analyticsEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.clipboardWrite, .clipboardWrite): return {
        guard case .clipboardWrite(let l) = lhs, case .clipboardWrite(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Pb_IsReadyToPayRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var apiVersion: UInt32 = 0

  public var apiVersionMinor: UInt32 = 0

  public var allowedPaymentMethods: [Pb_PaymentMethodSpecification] = []

  public var existingPaymentMethodRequired: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pb_PaymentDataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var merchantInfo: Pb_MerchantInfo {
    get {return _storage._merchantInfo ?? Pb_MerchantInfo()}
    set {_uniqueStorage()._merchantInfo = newValue}
  }
  /// Returns true if `merchantInfo` has been explicitly set.
  public var hasMerchantInfo: Bool {return _storage._merchantInfo != nil}
  /// Clears the value of `merchantInfo`. Subsequent reads from it will return its default value.
  public mutating func clearMerchantInfo() {_uniqueStorage()._merchantInfo = nil}

  public var apiVersion: UInt32 {
    get {return _storage._apiVersion}
    set {_uniqueStorage()._apiVersion = newValue}
  }

  public var apiVersionMinor: UInt32 {
    get {return _storage._apiVersionMinor}
    set {_uniqueStorage()._apiVersionMinor = newValue}
  }

  public var emailRequired: Bool {
    get {return _storage._emailRequired}
    set {_uniqueStorage()._emailRequired = newValue}
  }

  public var shippingAddressRequired: Bool {
    get {return _storage._shippingAddressRequired}
    set {_uniqueStorage()._shippingAddressRequired = newValue}
  }

  public var shippingAddressParameters: Pb_ShippingAddressParameters {
    get {return _storage._shippingAddressParameters ?? Pb_ShippingAddressParameters()}
    set {_uniqueStorage()._shippingAddressParameters = newValue}
  }
  /// Returns true if `shippingAddressParameters` has been explicitly set.
  public var hasShippingAddressParameters: Bool {return _storage._shippingAddressParameters != nil}
  /// Clears the value of `shippingAddressParameters`. Subsequent reads from it will return its default value.
  public mutating func clearShippingAddressParameters() {_uniqueStorage()._shippingAddressParameters = nil}

  public var allowedPaymentMethods: [Pb_PaymentMethodSpecification] {
    get {return _storage._allowedPaymentMethods}
    set {_uniqueStorage()._allowedPaymentMethods = newValue}
  }

  public var transactionInfo: Pb_TransactionInfo {
    get {return _storage._transactionInfo ?? Pb_TransactionInfo()}
    set {_uniqueStorage()._transactionInfo = newValue}
  }
  /// Returns true if `transactionInfo` has been explicitly set.
  public var hasTransactionInfo: Bool {return _storage._transactionInfo != nil}
  /// Clears the value of `transactionInfo`. Subsequent reads from it will return its default value.
  public mutating func clearTransactionInfo() {_uniqueStorage()._transactionInfo = nil}

  public var shippingOptionRequired: Bool {
    get {return _storage._shippingOptionRequired}
    set {_uniqueStorage()._shippingOptionRequired = newValue}
  }

  public var shippingOptionParameters: Pb_ShippingOptionParameters {
    get {return _storage._shippingOptionParameters ?? Pb_ShippingOptionParameters()}
    set {_uniqueStorage()._shippingOptionParameters = newValue}
  }
  /// Returns true if `shippingOptionParameters` has been explicitly set.
  public var hasShippingOptionParameters: Bool {return _storage._shippingOptionParameters != nil}
  /// Clears the value of `shippingOptionParameters`. Subsequent reads from it will return its default value.
  public mutating func clearShippingOptionParameters() {_uniqueStorage()._shippingOptionParameters = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Pb_MerchantInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var merchantID: String = String()

  public var merchantName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pb_ShippingAddressParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var allowedCountryCodes: [String] = []

  public var phoneNumberRequired: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pb_TransactionInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var transactionID: String = String()

  public var currencyCode: String = String()

  public var countryCode: String = String()

  public var totalPrice: String = String()

  public var totalPriceLabel: String = String()

  public var totalPriceStatus: String = String()

  public var transactionNote: String = String()

  public var checkoutOption: String = String()

  public var displayItems: [Pb_DisplayItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pb_DisplayItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var label: String = String()

  public var type: String = String()

  public var price: String = String()

  public var status: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pb_ShippingOptionParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var shippingOptions: [Pb_ShippingOption] = []

  public var defaultSelectedOptionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pb_ShippingOption {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var label: String = String()

  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pb_PaymentData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var apiVersion: UInt32 {
    get {return _storage._apiVersion}
    set {_uniqueStorage()._apiVersion = newValue}
  }

  public var apiVersionMinor: UInt32 {
    get {return _storage._apiVersionMinor}
    set {_uniqueStorage()._apiVersionMinor = newValue}
  }

  public var email: String {
    get {return _storage._email}
    set {_uniqueStorage()._email = newValue}
  }

  public var shippingAddress: Pb_Address {
    get {return _storage._shippingAddress ?? Pb_Address()}
    set {_uniqueStorage()._shippingAddress = newValue}
  }
  /// Returns true if `shippingAddress` has been explicitly set.
  public var hasShippingAddress: Bool {return _storage._shippingAddress != nil}
  /// Clears the value of `shippingAddress`. Subsequent reads from it will return its default value.
  public mutating func clearShippingAddress() {_uniqueStorage()._shippingAddress = nil}

  public var paymentMethodData: Pb_PaymentMethodData {
    get {return _storage._paymentMethodData ?? Pb_PaymentMethodData()}
    set {_uniqueStorage()._paymentMethodData = newValue}
  }
  /// Returns true if `paymentMethodData` has been explicitly set.
  public var hasPaymentMethodData: Bool {return _storage._paymentMethodData != nil}
  /// Clears the value of `paymentMethodData`. Subsequent reads from it will return its default value.
  public mutating func clearPaymentMethodData() {_uniqueStorage()._paymentMethodData = nil}

  public var shippingOptionData: Pb_SelectionOptionData {
    get {return _storage._shippingOptionData ?? Pb_SelectionOptionData()}
    set {_uniqueStorage()._shippingOptionData = newValue}
  }
  /// Returns true if `shippingOptionData` has been explicitly set.
  public var hasShippingOptionData: Bool {return _storage._shippingOptionData != nil}
  /// Clears the value of `shippingOptionData`. Subsequent reads from it will return its default value.
  public mutating func clearShippingOptionData() {_uniqueStorage()._shippingOptionData = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Pb_SelectionOptionData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pb_PaymentMethodData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: String = String()

  public var info: Pb_CardInfo {
    get {return _info ?? Pb_CardInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  public var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  public mutating func clearInfo() {self._info = nil}

  public var description_p: String = String()

  public var tokenizationData: Pb_PaymentMethodTokenizationData {
    get {return _tokenizationData ?? Pb_PaymentMethodTokenizationData()}
    set {_tokenizationData = newValue}
  }
  /// Returns true if `tokenizationData` has been explicitly set.
  public var hasTokenizationData: Bool {return self._tokenizationData != nil}
  /// Clears the value of `tokenizationData`. Subsequent reads from it will return its default value.
  public mutating func clearTokenizationData() {self._tokenizationData = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _info: Pb_CardInfo? = nil
  fileprivate var _tokenizationData: Pb_PaymentMethodTokenizationData? = nil
}

public struct Pb_CardInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var cardNetwork: String = String()

  public var cardDetails: String = String()

  public var billingAddress: Pb_Address {
    get {return _billingAddress ?? Pb_Address()}
    set {_billingAddress = newValue}
  }
  /// Returns true if `billingAddress` has been explicitly set.
  public var hasBillingAddress: Bool {return self._billingAddress != nil}
  /// Clears the value of `billingAddress`. Subsequent reads from it will return its default value.
  public mutating func clearBillingAddress() {self._billingAddress = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _billingAddress: Pb_Address? = nil
}

public struct Pb_Address {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var address1: String = String()

  public var address2: String = String()

  public var address3: String = String()

  public var locality: String = String()

  public var administrativeArea: String = String()

  public var countryCode: String = String()

  public var postalCode: String = String()

  public var sortingCode: String = String()

  public var phoneNumber: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pb_PaymentMethodTokenizationData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: String = String()

  public var token: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pb_PaymentMethodSpecification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: String = String()

  public var parameters: Pb_CardParameters {
    get {return _parameters ?? Pb_CardParameters()}
    set {_parameters = newValue}
  }
  /// Returns true if `parameters` has been explicitly set.
  public var hasParameters: Bool {return self._parameters != nil}
  /// Clears the value of `parameters`. Subsequent reads from it will return its default value.
  public mutating func clearParameters() {self._parameters = nil}

  public var tokenizationSpecification: Pb_TokenizationSpecification {
    get {return _tokenizationSpecification ?? Pb_TokenizationSpecification()}
    set {_tokenizationSpecification = newValue}
  }
  /// Returns true if `tokenizationSpecification` has been explicitly set.
  public var hasTokenizationSpecification: Bool {return self._tokenizationSpecification != nil}
  /// Clears the value of `tokenizationSpecification`. Subsequent reads from it will return its default value.
  public mutating func clearTokenizationSpecification() {self._tokenizationSpecification = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _parameters: Pb_CardParameters? = nil
  fileprivate var _tokenizationSpecification: Pb_TokenizationSpecification? = nil
}

public struct Pb_CardParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var allowedAuthMethods: [String] = []

  public var allowedCardNetworks: [String] = []

  public var allowPrepaidCards: Bool = false

  public var allowCreditCards: Bool = false

  public var billingAddressRequired: Bool = false

  public var billingAddressParameters: Pb_BillingAddressParameters {
    get {return _billingAddressParameters ?? Pb_BillingAddressParameters()}
    set {_billingAddressParameters = newValue}
  }
  /// Returns true if `billingAddressParameters` has been explicitly set.
  public var hasBillingAddressParameters: Bool {return self._billingAddressParameters != nil}
  /// Clears the value of `billingAddressParameters`. Subsequent reads from it will return its default value.
  public mutating func clearBillingAddressParameters() {self._billingAddressParameters = nil}

  public var cardNetworkParameters: Pb_CardNetworkParameters {
    get {return _cardNetworkParameters ?? Pb_CardNetworkParameters()}
    set {_cardNetworkParameters = newValue}
  }
  /// Returns true if `cardNetworkParameters` has been explicitly set.
  public var hasCardNetworkParameters: Bool {return self._cardNetworkParameters != nil}
  /// Clears the value of `cardNetworkParameters`. Subsequent reads from it will return its default value.
  public mutating func clearCardNetworkParameters() {self._cardNetworkParameters = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _billingAddressParameters: Pb_BillingAddressParameters? = nil
  fileprivate var _cardNetworkParameters: Pb_CardNetworkParameters? = nil
}

public struct Pb_TokenizationSpecification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: String = String()

  public var parameters: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pb_BillingAddressParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var format: String = String()

  public var phoneNumberRequired: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pb_CardNetworkParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var cardNetwork: String = String()

  public var acquirerBin: String = String()

  public var acquirerMerchantID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pb_MobileError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: UInt32 = 0

  public var message: String = String()

  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pb_ApplePayPaymentDataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var countryCode: String = String()

  public var currencyCode: String = String()

  public var total: Pb_ApplePayTotal {
    get {return _total ?? Pb_ApplePayTotal()}
    set {_total = newValue}
  }
  /// Returns true if `total` has been explicitly set.
  public var hasTotal: Bool {return self._total != nil}
  /// Clears the value of `total`. Subsequent reads from it will return its default value.
  public mutating func clearTotal() {self._total = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _total: Pb_ApplePayTotal? = nil
}

public struct Pb_ApplePayTotal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var label: String = String()

  public var amount: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pb_ApplePayPaymentData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: Pb_ApplePayPaymentToken {
    get {return _token ?? Pb_ApplePayPaymentToken()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: Pb_ApplePayPaymentToken? = nil
}

public struct Pb_ApplePayPaymentToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paymentData: String = String()

  public var transactionIdentifier: String = String()

  public var paymentMethod: Pb_ApplePaymentMethod {
    get {return _paymentMethod ?? Pb_ApplePaymentMethod()}
    set {_paymentMethod = newValue}
  }
  /// Returns true if `paymentMethod` has been explicitly set.
  public var hasPaymentMethod: Bool {return self._paymentMethod != nil}
  /// Clears the value of `paymentMethod`. Subsequent reads from it will return its default value.
  public mutating func clearPaymentMethod() {self._paymentMethod = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _paymentMethod: Pb_ApplePaymentMethod? = nil
}

public struct Pb_ApplePaymentMethod {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var displayName: String = String()

  public var network: String = String()

  public var type: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pb_MobileApplicationParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: String = String()

  public var deviceID: String = String()

  public var confirmationID: String = String()

  public var passwordEnabled: Bool = false

  public var biometryEnabled: Bool = false

  public var biometryAvailable: Bool = false

  public var fcmToken: String = String()

  public var myTrackerInstanceID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pb_MobileApplicationParamsUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: String = String()

  public var confirmationID: String = String()

  public var passwordEnabled: Bool = false

  public var biometryEnabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pb_CreateKeysRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var password: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pb_CreateKeysResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var publicKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pb_MobileAnalyticsEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var eventType: Pb_MobileAnalyticsEventType = .unspecified

  public var value: String = String()

  public var utmMedium: String = String()

  public var utmSource: String = String()

  public var utmCampaign: String = String()

  public var utmTerm: String = String()

  public var utmContent: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Pb_MobileEventType: @unchecked Sendable {}
extension Pb_MobileAnalyticsEventType: @unchecked Sendable {}
extension Pb_MobileEvent: @unchecked Sendable {}
extension Pb_MobileEvent.OneOf_Payload: @unchecked Sendable {}
extension Pb_IsReadyToPayRequest: @unchecked Sendable {}
extension Pb_PaymentDataRequest: @unchecked Sendable {}
extension Pb_MerchantInfo: @unchecked Sendable {}
extension Pb_ShippingAddressParameters: @unchecked Sendable {}
extension Pb_TransactionInfo: @unchecked Sendable {}
extension Pb_DisplayItem: @unchecked Sendable {}
extension Pb_ShippingOptionParameters: @unchecked Sendable {}
extension Pb_ShippingOption: @unchecked Sendable {}
extension Pb_PaymentData: @unchecked Sendable {}
extension Pb_SelectionOptionData: @unchecked Sendable {}
extension Pb_PaymentMethodData: @unchecked Sendable {}
extension Pb_CardInfo: @unchecked Sendable {}
extension Pb_Address: @unchecked Sendable {}
extension Pb_PaymentMethodTokenizationData: @unchecked Sendable {}
extension Pb_PaymentMethodSpecification: @unchecked Sendable {}
extension Pb_CardParameters: @unchecked Sendable {}
extension Pb_TokenizationSpecification: @unchecked Sendable {}
extension Pb_BillingAddressParameters: @unchecked Sendable {}
extension Pb_CardNetworkParameters: @unchecked Sendable {}
extension Pb_MobileError: @unchecked Sendable {}
extension Pb_ApplePayPaymentDataRequest: @unchecked Sendable {}
extension Pb_ApplePayTotal: @unchecked Sendable {}
extension Pb_ApplePayPaymentData: @unchecked Sendable {}
extension Pb_ApplePayPaymentToken: @unchecked Sendable {}
extension Pb_ApplePaymentMethod: @unchecked Sendable {}
extension Pb_MobileApplicationParams: @unchecked Sendable {}
extension Pb_MobileApplicationParamsUpdate: @unchecked Sendable {}
extension Pb_CreateKeysRequest: @unchecked Sendable {}
extension Pb_CreateKeysResponse: @unchecked Sendable {}
extension Pb_MobileAnalyticsEvent: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "pb"

extension Pb_MobileEventType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MOBILE_EVENT_UNSPECIFIED"),
    1: .same(proto: "MOBILE_EVENT_GOOGLEPAY_IS_READY_TO_PAY_REQUEST"),
    2: .same(proto: "MOBILE_EVENT_GOOGLEPAY_IS_READY_TO_PAY_RESPONSE"),
    3: .same(proto: "MOBILE_EVENT_GOOGLEPAY_PAYMENT_DATA_REQUEST"),
    4: .same(proto: "MOBILE_EVENT_GOOGLEPAY_PAYMENT_DATA_RESPONSE"),
    5: .same(proto: "MOBILE_EVENT_GOOGLEPAY_PAYMENT_DATA_ERROR"),
    6: .same(proto: "MOBILE_EVENT_APPLEPAY_IS_READY_TO_PAY_REQUEST"),
    7: .same(proto: "MOBILE_EVENT_APPLEPAY_IS_READY_TO_PAY_RESPONSE"),
    8: .same(proto: "MOBILE_EVENT_APPLEPAY_PAYMENT_DATA_REQUEST"),
    9: .same(proto: "MOBILE_EVENT_APPLEPAY_PAYMENT_DATA_RESPONSE"),
    10: .same(proto: "MOBILE_EVENT_APPLEPAY_PAYMENT_DATA_ERROR"),
    11: .same(proto: "MOBILE_EVENT_OPEN_URL_REQUEST"),
    12: .same(proto: "MOBILE_EVENT_BACK"),
    13: .same(proto: "MOBILE_EVENT_SHARE_URL_REQUEST"),
    14: .same(proto: "MOBILE_EVENT_GET_PARAMS_REQUEST"),
    15: .same(proto: "MOBILE_EVENT_GET_PARAMS_RESPONSE"),
    16: .same(proto: "MOBILE_EVENT_SET_PARAMS_REQUEST"),
    17: .same(proto: "MOBILE_EVENT_CREATE_KEYS_REQUEST"),
    18: .same(proto: "MOBILE_EVENT_CREATE_KEYS_RESPONSE"),
    19: .same(proto: "MOBILE_EVENT_PARAMS_UPDATED"),
    20: .same(proto: "MOBILE_EVENT_ANALYTICS_EVENT"),
    21: .same(proto: "MOBILE_EVENT_CLIPBOARD_WRITE"),
    22: .same(proto: "MOBILE_EVENT_REVIEW"),
  ]
}

extension Pb_MobileAnalyticsEventType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MOBILE_ANALYTICS_EVENT_TYPE_UNSPECIFIED"),
    1: .same(proto: "MOBILE_ANALYTICS_EVENT_TYPE_ANDROID_APP_INSTALL_REFERRER"),
    2: .same(proto: "MOBILE_ANALYTICS_EVENT_TYPE_ANDROID_IAU_INSTALL"),
    3: .same(proto: "MOBILE_ANALYTICS_EVENT_TYPE_ANDROID_IAU_CANCEL"),
  ]
}

extension Pb_MobileEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MobileEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "error"),
    3: .standard(proto: "is_ready_to_pay_request"),
    4: .standard(proto: "payment_data_request"),
    5: .standard(proto: "is_ready_to_pay"),
    6: .standard(proto: "payment_data"),
    7: .standard(proto: "applepay_payment_data_request"),
    8: .standard(proto: "applepay_payment_data"),
    9: .standard(proto: "open_url_request"),
    10: .standard(proto: "share_url_request"),
    11: .standard(proto: "application_params"),
    12: .standard(proto: "create_keys_request"),
    13: .standard(proto: "create_keys_response"),
    14: .standard(proto: "application_params_update"),
    15: .standard(proto: "analytics_event"),
    16: .standard(proto: "clipboard_write"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try {
        var v: Pb_MobileError?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .error(v)
        }
      }()
      case 3: try {
        var v: Pb_IsReadyToPayRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .isReadyToPayRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .isReadyToPayRequest(v)
        }
      }()
      case 4: try {
        var v: Pb_PaymentDataRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .paymentDataRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .paymentDataRequest(v)
        }
      }()
      case 5: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .isReadyToPay(v)
        }
      }()
      case 6: try {
        var v: Pb_PaymentData?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .paymentData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .paymentData(v)
        }
      }()
      case 7: try {
        var v: Pb_ApplePayPaymentDataRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .applepayPaymentDataRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .applepayPaymentDataRequest(v)
        }
      }()
      case 8: try {
        var v: Pb_ApplePayPaymentData?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .applepayPaymentData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .applepayPaymentData(v)
        }
      }()
      case 9: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .openURLRequest(v)
        }
      }()
      case 10: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .shareURLRequest(v)
        }
      }()
      case 11: try {
        var v: Pb_MobileApplicationParams?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .applicationParams(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .applicationParams(v)
        }
      }()
      case 12: try {
        var v: Pb_CreateKeysRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .createKeysRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .createKeysRequest(v)
        }
      }()
      case 13: try {
        var v: Pb_CreateKeysResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .createKeysResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .createKeysResponse(v)
        }
      }()
      case 14: try {
        var v: Pb_MobileApplicationParamsUpdate?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .applicationParamsUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .applicationParamsUpdate(v)
        }
      }()
      case 15: try {
        var v: Pb_MobileAnalyticsEvent?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .analyticsEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .analyticsEvent(v)
        }
      }()
      case 16: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .clipboardWrite(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .mobileEventUnspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    switch self.payload {
    case .error?: try {
      guard case .error(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .isReadyToPayRequest?: try {
      guard case .isReadyToPayRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .paymentDataRequest?: try {
      guard case .paymentDataRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .isReadyToPay?: try {
      guard case .isReadyToPay(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }()
    case .paymentData?: try {
      guard case .paymentData(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .applepayPaymentDataRequest?: try {
      guard case .applepayPaymentDataRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .applepayPaymentData?: try {
      guard case .applepayPaymentData(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .openURLRequest?: try {
      guard case .openURLRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    }()
    case .shareURLRequest?: try {
      guard case .shareURLRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 10)
    }()
    case .applicationParams?: try {
      guard case .applicationParams(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .createKeysRequest?: try {
      guard case .createKeysRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .createKeysResponse?: try {
      guard case .createKeysResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .applicationParamsUpdate?: try {
      guard case .applicationParamsUpdate(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .analyticsEvent?: try {
      guard case .analyticsEvent(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .clipboardWrite?: try {
      guard case .clipboardWrite(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 16)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_MobileEvent, rhs: Pb_MobileEvent) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_IsReadyToPayRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IsReadyToPayRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "api_version"),
    2: .standard(proto: "api_version_minor"),
    3: .standard(proto: "allowed_payment_methods"),
    4: .standard(proto: "existing_payment_method_required"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.apiVersion) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.apiVersionMinor) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.allowedPaymentMethods) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.existingPaymentMethodRequired) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.apiVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.apiVersion, fieldNumber: 1)
    }
    if self.apiVersionMinor != 0 {
      try visitor.visitSingularUInt32Field(value: self.apiVersionMinor, fieldNumber: 2)
    }
    if !self.allowedPaymentMethods.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.allowedPaymentMethods, fieldNumber: 3)
    }
    if self.existingPaymentMethodRequired != false {
      try visitor.visitSingularBoolField(value: self.existingPaymentMethodRequired, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_IsReadyToPayRequest, rhs: Pb_IsReadyToPayRequest) -> Bool {
    if lhs.apiVersion != rhs.apiVersion {return false}
    if lhs.apiVersionMinor != rhs.apiVersionMinor {return false}
    if lhs.allowedPaymentMethods != rhs.allowedPaymentMethods {return false}
    if lhs.existingPaymentMethodRequired != rhs.existingPaymentMethodRequired {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_PaymentDataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PaymentDataRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "merchant_info"),
    2: .standard(proto: "api_version"),
    3: .standard(proto: "api_version_minor"),
    4: .standard(proto: "email_required"),
    5: .standard(proto: "shipping_address_required"),
    6: .standard(proto: "shipping_address_parameters"),
    7: .standard(proto: "allowed_payment_methods"),
    8: .standard(proto: "transaction_info"),
    9: .standard(proto: "shipping_option_required"),
    10: .standard(proto: "shipping_option_parameters"),
  ]

  fileprivate class _StorageClass {
    var _merchantInfo: Pb_MerchantInfo? = nil
    var _apiVersion: UInt32 = 0
    var _apiVersionMinor: UInt32 = 0
    var _emailRequired: Bool = false
    var _shippingAddressRequired: Bool = false
    var _shippingAddressParameters: Pb_ShippingAddressParameters? = nil
    var _allowedPaymentMethods: [Pb_PaymentMethodSpecification] = []
    var _transactionInfo: Pb_TransactionInfo? = nil
    var _shippingOptionRequired: Bool = false
    var _shippingOptionParameters: Pb_ShippingOptionParameters? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _merchantInfo = source._merchantInfo
      _apiVersion = source._apiVersion
      _apiVersionMinor = source._apiVersionMinor
      _emailRequired = source._emailRequired
      _shippingAddressRequired = source._shippingAddressRequired
      _shippingAddressParameters = source._shippingAddressParameters
      _allowedPaymentMethods = source._allowedPaymentMethods
      _transactionInfo = source._transactionInfo
      _shippingOptionRequired = source._shippingOptionRequired
      _shippingOptionParameters = source._shippingOptionParameters
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._merchantInfo) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._apiVersion) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._apiVersionMinor) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._emailRequired) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._shippingAddressRequired) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._shippingAddressParameters) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._allowedPaymentMethods) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._transactionInfo) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._shippingOptionRequired) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._shippingOptionParameters) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._merchantInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if _storage._apiVersion != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._apiVersion, fieldNumber: 2)
      }
      if _storage._apiVersionMinor != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._apiVersionMinor, fieldNumber: 3)
      }
      if _storage._emailRequired != false {
        try visitor.visitSingularBoolField(value: _storage._emailRequired, fieldNumber: 4)
      }
      if _storage._shippingAddressRequired != false {
        try visitor.visitSingularBoolField(value: _storage._shippingAddressRequired, fieldNumber: 5)
      }
      try { if let v = _storage._shippingAddressParameters {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._allowedPaymentMethods.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._allowedPaymentMethods, fieldNumber: 7)
      }
      try { if let v = _storage._transactionInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if _storage._shippingOptionRequired != false {
        try visitor.visitSingularBoolField(value: _storage._shippingOptionRequired, fieldNumber: 9)
      }
      try { if let v = _storage._shippingOptionParameters {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_PaymentDataRequest, rhs: Pb_PaymentDataRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._merchantInfo != rhs_storage._merchantInfo {return false}
        if _storage._apiVersion != rhs_storage._apiVersion {return false}
        if _storage._apiVersionMinor != rhs_storage._apiVersionMinor {return false}
        if _storage._emailRequired != rhs_storage._emailRequired {return false}
        if _storage._shippingAddressRequired != rhs_storage._shippingAddressRequired {return false}
        if _storage._shippingAddressParameters != rhs_storage._shippingAddressParameters {return false}
        if _storage._allowedPaymentMethods != rhs_storage._allowedPaymentMethods {return false}
        if _storage._transactionInfo != rhs_storage._transactionInfo {return false}
        if _storage._shippingOptionRequired != rhs_storage._shippingOptionRequired {return false}
        if _storage._shippingOptionParameters != rhs_storage._shippingOptionParameters {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_MerchantInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MerchantInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "merchant_id"),
    2: .standard(proto: "merchant_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.merchantID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.merchantName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.merchantID.isEmpty {
      try visitor.visitSingularStringField(value: self.merchantID, fieldNumber: 1)
    }
    if !self.merchantName.isEmpty {
      try visitor.visitSingularStringField(value: self.merchantName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_MerchantInfo, rhs: Pb_MerchantInfo) -> Bool {
    if lhs.merchantID != rhs.merchantID {return false}
    if lhs.merchantName != rhs.merchantName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_ShippingAddressParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShippingAddressParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "allowed_country_codes"),
    2: .standard(proto: "phone_number_required"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.allowedCountryCodes) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.phoneNumberRequired) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.allowedCountryCodes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowedCountryCodes, fieldNumber: 1)
    }
    if self.phoneNumberRequired != false {
      try visitor.visitSingularBoolField(value: self.phoneNumberRequired, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_ShippingAddressParameters, rhs: Pb_ShippingAddressParameters) -> Bool {
    if lhs.allowedCountryCodes != rhs.allowedCountryCodes {return false}
    if lhs.phoneNumberRequired != rhs.phoneNumberRequired {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_TransactionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_id"),
    2: .standard(proto: "currency_code"),
    3: .standard(proto: "country_code"),
    4: .standard(proto: "total_price"),
    5: .standard(proto: "total_price_label"),
    6: .standard(proto: "total_price_status"),
    7: .standard(proto: "transaction_note"),
    8: .standard(proto: "checkout_option"),
    9: .standard(proto: "display_items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.transactionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.currencyCode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.countryCode) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.totalPrice) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.totalPriceLabel) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.totalPriceStatus) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.transactionNote) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.checkoutOption) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.displayItems) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactionID.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionID, fieldNumber: 1)
    }
    if !self.currencyCode.isEmpty {
      try visitor.visitSingularStringField(value: self.currencyCode, fieldNumber: 2)
    }
    if !self.countryCode.isEmpty {
      try visitor.visitSingularStringField(value: self.countryCode, fieldNumber: 3)
    }
    if !self.totalPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.totalPrice, fieldNumber: 4)
    }
    if !self.totalPriceLabel.isEmpty {
      try visitor.visitSingularStringField(value: self.totalPriceLabel, fieldNumber: 5)
    }
    if !self.totalPriceStatus.isEmpty {
      try visitor.visitSingularStringField(value: self.totalPriceStatus, fieldNumber: 6)
    }
    if !self.transactionNote.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionNote, fieldNumber: 7)
    }
    if !self.checkoutOption.isEmpty {
      try visitor.visitSingularStringField(value: self.checkoutOption, fieldNumber: 8)
    }
    if !self.displayItems.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.displayItems, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_TransactionInfo, rhs: Pb_TransactionInfo) -> Bool {
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs.currencyCode != rhs.currencyCode {return false}
    if lhs.countryCode != rhs.countryCode {return false}
    if lhs.totalPrice != rhs.totalPrice {return false}
    if lhs.totalPriceLabel != rhs.totalPriceLabel {return false}
    if lhs.totalPriceStatus != rhs.totalPriceStatus {return false}
    if lhs.transactionNote != rhs.transactionNote {return false}
    if lhs.checkoutOption != rhs.checkoutOption {return false}
    if lhs.displayItems != rhs.displayItems {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_DisplayItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DisplayItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "type"),
    3: .same(proto: "price"),
    4: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.price) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    if !self.price.isEmpty {
      try visitor.visitSingularStringField(value: self.price, fieldNumber: 3)
    }
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_DisplayItem, rhs: Pb_DisplayItem) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.type != rhs.type {return false}
    if lhs.price != rhs.price {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_ShippingOptionParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShippingOptionParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "shipping_options"),
    2: .standard(proto: "default_selected_option_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.shippingOptions) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.defaultSelectedOptionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.shippingOptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.shippingOptions, fieldNumber: 1)
    }
    if !self.defaultSelectedOptionID.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultSelectedOptionID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_ShippingOptionParameters, rhs: Pb_ShippingOptionParameters) -> Bool {
    if lhs.shippingOptions != rhs.shippingOptions {return false}
    if lhs.defaultSelectedOptionID != rhs.defaultSelectedOptionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_ShippingOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShippingOption"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "label"),
    3: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_ShippingOption, rhs: Pb_ShippingOption) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.label != rhs.label {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_PaymentData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PaymentData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "api_version"),
    2: .standard(proto: "api_version_minor"),
    3: .same(proto: "email"),
    4: .standard(proto: "shipping_address"),
    5: .standard(proto: "payment_method_data"),
    6: .standard(proto: "shipping_option_data"),
  ]

  fileprivate class _StorageClass {
    var _apiVersion: UInt32 = 0
    var _apiVersionMinor: UInt32 = 0
    var _email: String = String()
    var _shippingAddress: Pb_Address? = nil
    var _paymentMethodData: Pb_PaymentMethodData? = nil
    var _shippingOptionData: Pb_SelectionOptionData? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _apiVersion = source._apiVersion
      _apiVersionMinor = source._apiVersionMinor
      _email = source._email
      _shippingAddress = source._shippingAddress
      _paymentMethodData = source._paymentMethodData
      _shippingOptionData = source._shippingOptionData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._apiVersion) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._apiVersionMinor) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._email) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._shippingAddress) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._paymentMethodData) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._shippingOptionData) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._apiVersion != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._apiVersion, fieldNumber: 1)
      }
      if _storage._apiVersionMinor != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._apiVersionMinor, fieldNumber: 2)
      }
      if !_storage._email.isEmpty {
        try visitor.visitSingularStringField(value: _storage._email, fieldNumber: 3)
      }
      try { if let v = _storage._shippingAddress {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._paymentMethodData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._shippingOptionData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_PaymentData, rhs: Pb_PaymentData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._apiVersion != rhs_storage._apiVersion {return false}
        if _storage._apiVersionMinor != rhs_storage._apiVersionMinor {return false}
        if _storage._email != rhs_storage._email {return false}
        if _storage._shippingAddress != rhs_storage._shippingAddress {return false}
        if _storage._paymentMethodData != rhs_storage._paymentMethodData {return false}
        if _storage._shippingOptionData != rhs_storage._shippingOptionData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_SelectionOptionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SelectionOptionData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_SelectionOptionData, rhs: Pb_SelectionOptionData) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_PaymentMethodData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PaymentMethodData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "info"),
    3: .same(proto: "description"),
    4: .standard(proto: "tokenization_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._tokenizationData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    try { if let v = self._tokenizationData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_PaymentMethodData, rhs: Pb_PaymentMethodData) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._info != rhs._info {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._tokenizationData != rhs._tokenizationData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_CardInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CardInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "card_network"),
    2: .standard(proto: "card_details"),
    3: .standard(proto: "billing_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cardNetwork) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cardDetails) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._billingAddress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.cardNetwork.isEmpty {
      try visitor.visitSingularStringField(value: self.cardNetwork, fieldNumber: 1)
    }
    if !self.cardDetails.isEmpty {
      try visitor.visitSingularStringField(value: self.cardDetails, fieldNumber: 2)
    }
    try { if let v = self._billingAddress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_CardInfo, rhs: Pb_CardInfo) -> Bool {
    if lhs.cardNetwork != rhs.cardNetwork {return false}
    if lhs.cardDetails != rhs.cardDetails {return false}
    if lhs._billingAddress != rhs._billingAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_Address: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Address"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "address1"),
    3: .same(proto: "address2"),
    4: .same(proto: "address3"),
    5: .same(proto: "locality"),
    6: .standard(proto: "administrative_area"),
    7: .standard(proto: "country_code"),
    8: .standard(proto: "postal_code"),
    9: .standard(proto: "sorting_code"),
    10: .standard(proto: "phone_number"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.address1) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.address2) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.address3) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.locality) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.administrativeArea) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.countryCode) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.postalCode) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.sortingCode) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.phoneNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.address1.isEmpty {
      try visitor.visitSingularStringField(value: self.address1, fieldNumber: 2)
    }
    if !self.address2.isEmpty {
      try visitor.visitSingularStringField(value: self.address2, fieldNumber: 3)
    }
    if !self.address3.isEmpty {
      try visitor.visitSingularStringField(value: self.address3, fieldNumber: 4)
    }
    if !self.locality.isEmpty {
      try visitor.visitSingularStringField(value: self.locality, fieldNumber: 5)
    }
    if !self.administrativeArea.isEmpty {
      try visitor.visitSingularStringField(value: self.administrativeArea, fieldNumber: 6)
    }
    if !self.countryCode.isEmpty {
      try visitor.visitSingularStringField(value: self.countryCode, fieldNumber: 7)
    }
    if !self.postalCode.isEmpty {
      try visitor.visitSingularStringField(value: self.postalCode, fieldNumber: 8)
    }
    if !self.sortingCode.isEmpty {
      try visitor.visitSingularStringField(value: self.sortingCode, fieldNumber: 9)
    }
    if !self.phoneNumber.isEmpty {
      try visitor.visitSingularStringField(value: self.phoneNumber, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_Address, rhs: Pb_Address) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.address1 != rhs.address1 {return false}
    if lhs.address2 != rhs.address2 {return false}
    if lhs.address3 != rhs.address3 {return false}
    if lhs.locality != rhs.locality {return false}
    if lhs.administrativeArea != rhs.administrativeArea {return false}
    if lhs.countryCode != rhs.countryCode {return false}
    if lhs.postalCode != rhs.postalCode {return false}
    if lhs.sortingCode != rhs.sortingCode {return false}
    if lhs.phoneNumber != rhs.phoneNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_PaymentMethodTokenizationData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PaymentMethodTokenizationData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_PaymentMethodTokenizationData, rhs: Pb_PaymentMethodTokenizationData) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_PaymentMethodSpecification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PaymentMethodSpecification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "parameters"),
    3: .standard(proto: "tokenization_specification"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._parameters) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._tokenizationSpecification) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    try { if let v = self._parameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._tokenizationSpecification {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_PaymentMethodSpecification, rhs: Pb_PaymentMethodSpecification) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._parameters != rhs._parameters {return false}
    if lhs._tokenizationSpecification != rhs._tokenizationSpecification {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_CardParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CardParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "allowed_auth_methods"),
    2: .standard(proto: "allowed_card_networks"),
    3: .standard(proto: "allow_prepaid_cards"),
    4: .standard(proto: "allow_credit_cards"),
    5: .standard(proto: "billing_address_required"),
    6: .standard(proto: "billing_address_parameters"),
    7: .standard(proto: "card_network_parameters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.allowedAuthMethods) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.allowedCardNetworks) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.allowPrepaidCards) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.allowCreditCards) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.billingAddressRequired) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._billingAddressParameters) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._cardNetworkParameters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.allowedAuthMethods.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowedAuthMethods, fieldNumber: 1)
    }
    if !self.allowedCardNetworks.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowedCardNetworks, fieldNumber: 2)
    }
    if self.allowPrepaidCards != false {
      try visitor.visitSingularBoolField(value: self.allowPrepaidCards, fieldNumber: 3)
    }
    if self.allowCreditCards != false {
      try visitor.visitSingularBoolField(value: self.allowCreditCards, fieldNumber: 4)
    }
    if self.billingAddressRequired != false {
      try visitor.visitSingularBoolField(value: self.billingAddressRequired, fieldNumber: 5)
    }
    try { if let v = self._billingAddressParameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._cardNetworkParameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_CardParameters, rhs: Pb_CardParameters) -> Bool {
    if lhs.allowedAuthMethods != rhs.allowedAuthMethods {return false}
    if lhs.allowedCardNetworks != rhs.allowedCardNetworks {return false}
    if lhs.allowPrepaidCards != rhs.allowPrepaidCards {return false}
    if lhs.allowCreditCards != rhs.allowCreditCards {return false}
    if lhs.billingAddressRequired != rhs.billingAddressRequired {return false}
    if lhs._billingAddressParameters != rhs._billingAddressParameters {return false}
    if lhs._cardNetworkParameters != rhs._cardNetworkParameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_TokenizationSpecification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenizationSpecification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "parameters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.parameters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.parameters.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.parameters, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_TokenizationSpecification, rhs: Pb_TokenizationSpecification) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.parameters != rhs.parameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_BillingAddressParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BillingAddressParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "format"),
    2: .standard(proto: "phone_number_required"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.format) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.phoneNumberRequired) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.format.isEmpty {
      try visitor.visitSingularStringField(value: self.format, fieldNumber: 1)
    }
    if self.phoneNumberRequired != false {
      try visitor.visitSingularBoolField(value: self.phoneNumberRequired, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_BillingAddressParameters, rhs: Pb_BillingAddressParameters) -> Bool {
    if lhs.format != rhs.format {return false}
    if lhs.phoneNumberRequired != rhs.phoneNumberRequired {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_CardNetworkParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CardNetworkParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "card_network"),
    2: .standard(proto: "acquirer_bin"),
    3: .standard(proto: "acquirer_merchant_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cardNetwork) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.acquirerBin) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.acquirerMerchantID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cardNetwork.isEmpty {
      try visitor.visitSingularStringField(value: self.cardNetwork, fieldNumber: 1)
    }
    if !self.acquirerBin.isEmpty {
      try visitor.visitSingularStringField(value: self.acquirerBin, fieldNumber: 2)
    }
    if !self.acquirerMerchantID.isEmpty {
      try visitor.visitSingularStringField(value: self.acquirerMerchantID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_CardNetworkParameters, rhs: Pb_CardNetworkParameters) -> Bool {
    if lhs.cardNetwork != rhs.cardNetwork {return false}
    if lhs.acquirerBin != rhs.acquirerBin {return false}
    if lhs.acquirerMerchantID != rhs.acquirerMerchantID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_MobileError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MobileError"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularUInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_MobileError, rhs: Pb_MobileError) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_ApplePayPaymentDataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApplePayPaymentDataRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "country_code"),
    2: .standard(proto: "currency_code"),
    3: .same(proto: "total"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.countryCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.currencyCode) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._total) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.countryCode.isEmpty {
      try visitor.visitSingularStringField(value: self.countryCode, fieldNumber: 1)
    }
    if !self.currencyCode.isEmpty {
      try visitor.visitSingularStringField(value: self.currencyCode, fieldNumber: 2)
    }
    try { if let v = self._total {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_ApplePayPaymentDataRequest, rhs: Pb_ApplePayPaymentDataRequest) -> Bool {
    if lhs.countryCode != rhs.countryCode {return false}
    if lhs.currencyCode != rhs.currencyCode {return false}
    if lhs._total != rhs._total {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_ApplePayTotal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApplePayTotal"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_ApplePayTotal, rhs: Pb_ApplePayTotal) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_ApplePayPaymentData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApplePayPaymentData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_ApplePayPaymentData, rhs: Pb_ApplePayPaymentData) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_ApplePayPaymentToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApplePayPaymentToken"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "payment_data"),
    2: .standard(proto: "transaction_identifier"),
    3: .standard(proto: "payment_method"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.paymentData) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.transactionIdentifier) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._paymentMethod) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.paymentData.isEmpty {
      try visitor.visitSingularStringField(value: self.paymentData, fieldNumber: 1)
    }
    if !self.transactionIdentifier.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionIdentifier, fieldNumber: 2)
    }
    try { if let v = self._paymentMethod {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_ApplePayPaymentToken, rhs: Pb_ApplePayPaymentToken) -> Bool {
    if lhs.paymentData != rhs.paymentData {return false}
    if lhs.transactionIdentifier != rhs.transactionIdentifier {return false}
    if lhs._paymentMethod != rhs._paymentMethod {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_ApplePaymentMethod: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApplePaymentMethod"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "display_name"),
    2: .same(proto: "network"),
    3: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.network) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 1)
    }
    if !self.network.isEmpty {
      try visitor.visitSingularStringField(value: self.network, fieldNumber: 2)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_ApplePaymentMethod, rhs: Pb_ApplePaymentMethod) -> Bool {
    if lhs.displayName != rhs.displayName {return false}
    if lhs.network != rhs.network {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_MobileApplicationParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MobileApplicationParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "device_id"),
    3: .standard(proto: "confirmation_id"),
    4: .standard(proto: "password_enabled"),
    5: .standard(proto: "biometry_enabled"),
    6: .standard(proto: "biometry_available"),
    7: .standard(proto: "fcm_token"),
    8: .standard(proto: "my_tracker_instance_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.confirmationID) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.passwordEnabled) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.biometryEnabled) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.biometryAvailable) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.fcmToken) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.myTrackerInstanceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 2)
    }
    if !self.confirmationID.isEmpty {
      try visitor.visitSingularStringField(value: self.confirmationID, fieldNumber: 3)
    }
    if self.passwordEnabled != false {
      try visitor.visitSingularBoolField(value: self.passwordEnabled, fieldNumber: 4)
    }
    if self.biometryEnabled != false {
      try visitor.visitSingularBoolField(value: self.biometryEnabled, fieldNumber: 5)
    }
    if self.biometryAvailable != false {
      try visitor.visitSingularBoolField(value: self.biometryAvailable, fieldNumber: 6)
    }
    if !self.fcmToken.isEmpty {
      try visitor.visitSingularStringField(value: self.fcmToken, fieldNumber: 7)
    }
    if !self.myTrackerInstanceID.isEmpty {
      try visitor.visitSingularStringField(value: self.myTrackerInstanceID, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_MobileApplicationParams, rhs: Pb_MobileApplicationParams) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.confirmationID != rhs.confirmationID {return false}
    if lhs.passwordEnabled != rhs.passwordEnabled {return false}
    if lhs.biometryEnabled != rhs.biometryEnabled {return false}
    if lhs.biometryAvailable != rhs.biometryAvailable {return false}
    if lhs.fcmToken != rhs.fcmToken {return false}
    if lhs.myTrackerInstanceID != rhs.myTrackerInstanceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_MobileApplicationParamsUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MobileApplicationParamsUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "confirmation_id"),
    3: .standard(proto: "password_enabled"),
    4: .standard(proto: "biometry_enabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.confirmationID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.passwordEnabled) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.biometryEnabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.confirmationID.isEmpty {
      try visitor.visitSingularStringField(value: self.confirmationID, fieldNumber: 2)
    }
    if self.passwordEnabled != false {
      try visitor.visitSingularBoolField(value: self.passwordEnabled, fieldNumber: 3)
    }
    if self.biometryEnabled != false {
      try visitor.visitSingularBoolField(value: self.biometryEnabled, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_MobileApplicationParamsUpdate, rhs: Pb_MobileApplicationParamsUpdate) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.confirmationID != rhs.confirmationID {return false}
    if lhs.passwordEnabled != rhs.passwordEnabled {return false}
    if lhs.biometryEnabled != rhs.biometryEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_CreateKeysRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateKeysRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "password"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.password) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_CreateKeysRequest, rhs: Pb_CreateKeysRequest) -> Bool {
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_CreateKeysResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateKeysResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.publicKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_CreateKeysResponse, rhs: Pb_CreateKeysResponse) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_MobileAnalyticsEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MobileAnalyticsEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_type"),
    2: .same(proto: "value"),
    3: .standard(proto: "utm_medium"),
    4: .standard(proto: "utm_source"),
    5: .standard(proto: "utm_campaign"),
    6: .standard(proto: "utm_term"),
    7: .standard(proto: "utm_content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.eventType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.utmMedium) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.utmSource) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.utmCampaign) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.utmTerm) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.utmContent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.eventType != .unspecified {
      try visitor.visitSingularEnumField(value: self.eventType, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    if !self.utmMedium.isEmpty {
      try visitor.visitSingularStringField(value: self.utmMedium, fieldNumber: 3)
    }
    if !self.utmSource.isEmpty {
      try visitor.visitSingularStringField(value: self.utmSource, fieldNumber: 4)
    }
    if !self.utmCampaign.isEmpty {
      try visitor.visitSingularStringField(value: self.utmCampaign, fieldNumber: 5)
    }
    if !self.utmTerm.isEmpty {
      try visitor.visitSingularStringField(value: self.utmTerm, fieldNumber: 6)
    }
    if !self.utmContent.isEmpty {
      try visitor.visitSingularStringField(value: self.utmContent, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_MobileAnalyticsEvent, rhs: Pb_MobileAnalyticsEvent) -> Bool {
    if lhs.eventType != rhs.eventType {return false}
    if lhs.value != rhs.value {return false}
    if lhs.utmMedium != rhs.utmMedium {return false}
    if lhs.utmSource != rhs.utmSource {return false}
    if lhs.utmCampaign != rhs.utmCampaign {return false}
    if lhs.utmTerm != rhs.utmTerm {return false}
    if lhs.utmContent != rhs.utmContent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
